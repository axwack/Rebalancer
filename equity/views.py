from django.http import HttpResponse, Http404, JsonResponsefrom django.template import RequestContextfrom django.conf import settingsfrom django.core.urlresolvers import reversefrom equity.models import Account, ClassificationNames, AllocationNodesfrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParser, FormParserfrom equity.serializers import AccountSerializer, ClassificationNamesSerializer, UserSecuritySelectionModelSerializers, \    SecuritySelectionModelSerializers, FeedSerializerfrom rest_framework.decorators import parser_classesfrom equity.models import AllocationModels, AccountFilters, SecuritySelectionModels, UserSecuritySelectionModel, Feedsfrom django.core import serializersfrom django.shortcuts import render, render_to_responsefrom forms import ModelNameForm, AccountParametersForm, AccountFilterForm, AccountSelectionForm, \    SecuritySelectionModelForm, SecuritiesFormfrom django.contrib import messagesfrom utils import JSONTree, UpdateJSONTree, DeleteJSONTreeimport jsonfrom equity.algorithims import SumOfNodesfrom django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturnedfrom django.views import genericfrom django.views.decorators.http import require_POSTimport os, new, csvfrom equity.utils import csvFileReaderget = lambda node_id: UserSecuritySelectionModel.objects.get(pk=node_id)class JSONResponse(HttpResponse):    """    An HttpResponse that renders its content into JSON.    """    def __init__(self, data, **kwargs):        content = JSONRenderer().render(data)        kwargs['content_type'] = 'application/json'        super(JSONResponse, self).__init__(content, **kwargs)# Create your views here.def custom_proc(request):    "A context processor that provides 'app', 'user' and 'ip_address'."    return {        'app': 'My app',        'user': request.user,        'ip_address': request.META['REMOTE_ADDR'],    }def home(request):    return render(request, "home.html", {})def index(request):    return render(request, "index.html", {'STATIC_URL': settings.STATIC_URL})def newRebalance(request):  # 1st Page for New Rebalance => NewRebalance2    if request.method == "POST":        form = AccountParametersForm(request.POST)        if form.is_valid():            rebalanceName = form.cleaned_data['rebalanceName']            saleType = form.cleaned_data['saleType']            buySell = form.cleaned_data['buySell']            reviewCurrentSale = form.cleaned_data['reviewCurrentSale']            adjustCashAfterRebal = form.cleaned_data['adjustCashAfterRebal']            adjustWgtAfterRebal = form.cleaned_data['adjustWgtAfterRebal']            taxLots = form.cleaned_data['taxLots']            form.save()            return render(request, 'NewRebalance_2.html', {'account_selection_form': AccountSelectionForm()})    else:        form = AccountParametersForm()    return render(request, 'NewRebalance.html', {'account_parameters_form': form})def accountSelections(request):  # NewRebalnce 2: AccountParameters with Accounts and Trading Form    if request.method == "POST":        form = AccountSelectionForm(request.POST)        if form.is_valid():            acctFilterName = form.data['acctFilterName']            excludeClassification = form.data['excludeClassification']            tradingCash = form.data['tradingCash']            form.save()            return render(request, 'NewRebalance_3.html')    else:        form = AccountSelectionForm()    return render(request, 'NewRebalance2.html', {'account_selections_form': form})def accounts(request):    c = RequestContext(request, '', processors=[custom_proc])    return render(request, 'accounts.html', context=c)def accountsByFilter(request):    if request.is_ajax():        id = request.GET.get('id')        acctFilter = AccountFilters.objects.get(acctFilterName=id)        accounts = acctFilter.accountName.all()        acctSerializer = AccountSerializer(accounts, many=True)        # serializers.serialize('json', accounts)    return JSONResponse(acctSerializer.data, status=201)def referenceData(request):    c = RequestContext(request, '', processors=[custom_proc])    return render(request, 'referenceData.html', context=c)def securities(request):    form = SecuritiesForm(request.POST)    return render(request, "securities.html", {'securities_form': form})def rulesCreation(request):    passdef accountParameters(request):    passdef modelParameters(request):    passdef accountSearchFilter(request):    # Saving and doing account Parameters    if request.method == "POST" or request.is_ajax():        form = AccountFilterForm(request.POST)        if form.is_valid():            acctFilterName = form.cleaned_data['acctFilterName']            accountName = form.cleaned_data['accountName']            o = form.save(commit=False)            o.save()            form.save_m2m()            return render(request, 'index.html')  # TODO: Create a modal popup to say it saved    else:        form = AccountFilterForm()    return render(request, 'AccountSearchFilter.html', {'account_filter_form': form})@csrf_exempt@parser_classes((JSONParser, FormParser,))def save_account_list(request):    """    List all Accounts, or create a new account.    """    try:        data = FormParser().parse(request)        serializer = AccountSerializer(data=data)        if serializer.is_valid():            serializer.save()            return JSONResponse(dict(Result='OK', Record=serializer.data), status=201)        return JSONResponse(serializer.errors, status=400)    except Exception:  # //TODO This may require more investigation. The original line of code here was to handle an issue on POST        # where the account needed to do a post request to get the data from the database. I'm leaving it here temporarily until more testing        accounts = Account.objects.all()        serializer = AccountSerializer(accounts, many=True)        return JSONResponse(dict(Result='OK', Records=serializer.data), status=201)@csrf_exemptdef get_account_list(request):    accounts = Account.objects.all()    serializer = AccountSerializer(accounts, many=True)    return JSONResponse(serializer.data, status=201)def getClassifications(request):    if request.is_ajax():        if request.GET.get('id') is not None:            id = request.GET['id']            rootNode = ClassificationNames.objects.get(id=id)            childNodes = rootNode.get_children()            classNameSerializers = ClassificationNamesSerializer(childNodes, many=True)        else:            baseClassName = ClassificationNames.objects.get(classificationName='Classification')            rootNode = baseClassName.get_root()            classNameSerializers = ClassificationNamesSerializer(rootNode)    return JsonResponse(classNameSerializers.data, safe=False)def getSavedClassificationModel(request, id):  # Comes from updateSecuritySelectionModels.html    try:        if (len(request.GET) == 0):  # Get the Root Node            userSecuritySelectionModels = UserSecuritySelectionModel.objects.get(ext_model_id=id)            rootNode = userSecuritySelectionModels.get_root()        elif request.is_ajax() and request.GET['ext_model_id'] is not None:            ext_model_id = request.GET['ext_model_id']            userSecuritySelectionModels = UserSecuritySelectionModel.objects.get(SSM_id=id, ext_model_id=ext_model_id)            childrenNodes = userSecuritySelectionModels.get_children()            SSMSerializer = UserSecuritySelectionModelSerializers(childrenNodes, many=True)            return JsonResponse(SSMSerializer.data, status=201, safe=False)        else:            userSecuritySelectionModels = UserSecuritySelectionModel.objects.get(SSM_id=id, ext_model_id=ext_model_id)            childrenNodes = userSecuritySelectionModels.get_children()    except MultipleObjectsReturned, e:        return JSONResponse(json.dumps({'error': 400, 'message': str(e)}), status=400)    except ObjectDoesNotExist:        # create root node        userSSM = UserSecuritySelectionModel()        rootNode = createStubNodes(userSSM, id)    SSMSerializer = UserSecuritySelectionModelSerializers(rootNode)    return JsonResponse(SSMSerializer.data, status=201, safe=False)def saveClassifications(request):    if request.is_ajax():        dataSource = request.POST.get('dataSource')        id = request.POST.get('ssmModel')        ssmModel = SecuritySelectionModels.objects.get(pk=id)        ssmModel.userCreatedModel = dataSource        result = JSONTree.JSONtoTreeBeard(dataSource)        ssmModel.save()    return JSONResponse(id, status=201)def updateSecuritySelectionModels(request):  # First Call for Update Workflow #1    return render(request, "updateModel.html")def updateModelWithSecurity(request, id):  # Second Call for Update    ModelName = SecuritySelectionModels.objects.get(id=id)    return render(request, "updateModelWithSecurity.html",                  {'id': id, 'securitySelectionModelName': ModelName.securitySelectionModelName})def deleteModel(request):    return render(request, "deleteModel.html")def deleteSecuritySelectionModels(request, id):    SecuritySelectionModels.objects.get(pk=id).delete()    return JsonResponse({'success': 'success'})def updateModelNodes(request):    try:        if request.is_ajax():            SSMModel = request.POST['ssmModel']            dataSource = json.loads(request.POST['dataSource'])            if not request.POST.get('deleteKeys[]', False) is False:                deleteNode = list()                for deleteKey in request.POST.getlist('deleteKeys[]'):                    deleteNode.append(deleteKey)                returnVal = DeleteJSONTree.deleteNodes(deleteNode, SSMModel)            else:                UpdateJSONTree.UpdateSSM(dataSource, SSMModel)    except AllocationModels.DoesNotExist:        raise Http404("Allocation Model does not exist")    return render(request, "createUpdateNewModelWeights.html",                  {'id': SSMModel, 'securitySelectionModelName': 'test'})  # TODO: Send the Model name back# Returns a newModel page for an ask to create a new modeldef updateModelWithTargetWeights(request):    get = lambda node_id: UserSecuritySelectionModel.objects.get(pk=node_id)    try:        if request.method == 'POST':            id = request.POST['models[0][id]']            ext_model_id = request.POST['models[0][ext_model_id]']            parent_id = request.POST['models[0][parentId]']            SSM_id = request.POST['models[0][SSM_id]']            tgt_weight = request.POST['models[0][tgtWeight]']            # Go to Rebalancer algorithim            updatedNodes = SumOfNodes.returnPercentOfNodeRoot(SSM_id, ext_model_id, tgt_weight)        userSelectionModelSerializer = UserSecuritySelectionModelSerializers(updatedNodes, many=True)    except AllocationModels.DoesNotExist:        raise Http404("Allocation Model does not exist")    json = JsonResponse(userSelectionModelSerializer.data, status=201, safe=False)    json['Model_Transaction_Type'] = 'Update'    return json    # return render('models', {'allocationModel': allocationModel})def get_SSMList(request):    if request.is_ajax():        SSMList = SecuritySelectionModels.objects.all();        serializer = SecuritySelectionModelSerializers(SSMList, many=True)    return JsonResponse(serializer.data, safe=False)def createModelWeights(request):    id = request.GET.get('id', '')    SSMModel = request.GET.get('SSMModel', None)    return render(request, "createUpdateNewModelWeights.html", {'id': id, 'securitySelectionModelName': SSMModel})def getModelTargetWeights(request):    SSM_id = request.GET.get('SSM_id', '')    id = request.GET.get('id', '')    if id == '':        rootNode = UserSecuritySelectionModel.objects.get(SSM_id=SSM_id, classificationName__isnull=True)    else:        rootNode = UserSecuritySelectionModel.objects.get(pk=id)    if request.is_ajax() and SSM_id is not None and id == "":        userSelectionModelSerializer = UserSecuritySelectionModelSerializers(rootNode)        if not rootNode.is_root():            node = rootNode.get_root()            data = serializers.serialize('json', node, use_natural_foreign_keys=True)            return JsonResponse(data, safe=False)        return JsonResponse(userSelectionModelSerializer.data, status=201, safe=False)    elif request.is_ajax() and id is not "" and SSM_id is not "":        childrenNodes = get(rootNode.pk).get_children()        userSelectionModelSerializer = UserSecuritySelectionModelSerializers(childrenNodes, many=True)        # if userSelectionModelSerializer.data is not None:        #     rootNode = flatten(userSelectionModelSerializer.data)    else:        childrenNodes = get(rootNode.pk).get_children()        userSelectionModelSerializer = UserSecuritySelectionModelSerializers(childrenNodes, many=True)    return JsonResponse(userSelectionModelSerializer.data, status=201, safe=False)  # ->> Add if we wnat to use this    #return JsonResponse (rootNode, status=201, safe=False)def Create_Model_Name(request):    # if this is a POST request we need to process the form data    errors_dict = {}    if request.method == "POST":        form = ModelNameForm(request.POST)        if request.is_ajax():            # TODO What do we do about primary key collision? How do we send a validation back?            # check whether it's valid:            if form.is_valid():                # process the data in form.cleaned_data as required                newModel = form.save(commit=False)                newModel.created_by = request.user                newModel.edited_by = request.user                newModel.save()                messages.success(request, 'New Model Created.')                classificationName = ClassificationNames.objects.get(id=1)                node = AllocationNodes(                        allocationModel=newModel,                        classificationName=classificationName,                        level=1                )                node.save()                allocNodes = AllocationNodes.objects.get(allocationModel=newModel.id)                data = serializers.serialize('json', [allocNodes], indent=2, use_natural_foreign_keys=True,                                             use_natural_primary_keys=True)                return JSONResponse(data, status=201)            else:                if form.errors:                    if form.errors:                        for error in form.errors:                            e = form.errors[error]                            errors_dict[error] = e                messages.error(request, e)                return JSONResponse(errors_dict, status=404)    else:        form = ModelNameForm()    return render(request, 'createNewModel.html', {'form': form})def createSecuritySelectionModels(request):    storage = messages.get_messages(request)    if request.is_ajax():        return JSONResponse(accounts, status=201)    elif request.method == 'POST':        form = SecuritySelectionModelForm(request.POST)        if form.is_valid():            ssm = form.save();            messages.add_message(request, messages.SUCCESS, 'Model Created and Saved.')            c = {                "id": ssm.id,                "securitySelectionModelName": ssm.securitySelectionModelName            }            return render(request, 'createNewModelWithSecurity.html', c)        else:            return render(request, 'createNewModel.html', {'security_selection_model_form': form})    else:        form = SecuritySelectionModelForm()    return render(request, 'createNewModel.html', {'security_selection_model_form': form})def createSSMModels(request, clean_data):    passdef flatten(item):    myArray = {}    for i in item:        for k, v in i.items():            if k == "parent":                print k, v['id']                myArray[k] = v['id']            elif k == 'SSM':                myArray['securitySelectionModelName'] = v['securitySelectionModelName']            elif k == "classificationName":                myArray[k] = v['classificationName']            else:                myArray[k] = v    return myArraydef createStubNodes(userSSM, id):    # create the actual root node    userSSM.SSM = SecuritySelectionModels.objects.get(pk=id)    userSSM.ext_model_id = userSSM.SSM.id    userSSM.parent = None    userSSM.currWeight = 0    userSSM.isSSMNameNode = True    userSSM.tgtWeight = 0    userSSM.hasChildNode = True    root = UserSecuritySelectionModel.add_root(instance=userSSM)    # create the cashNode    CashNode = UserSecuritySelectionModel()    CashNode.SSM = SecuritySelectionModels.objects.get(pk=id)    CashNode.classificationName = ClassificationNames.objects.get(classificationName='Cash')    CashNode.ext_model_id = CashNode.classificationName.id    CashNode.parent = None    CashNode.currWeight = 0    CashNode.isSSMNameNode = False    CashNode.tgtWeight = 0    CashNode.hasChildNode = False    root.add_child(instance=CashNode)    return rootdef systemFeeds(request):    if request.method == 'GET' and request.path == "/editSystemFeeds/":        return render(request, 'SysAdmin/sysAdmin_feeds.html')    elif request.path == '/systemFeeds/':        _feeds = Feeds.objects.all()        feedSerializers = FeedSerializer(_feeds, many=True)        return JsonResponse(feedSerializers.data, safe=False, status=201)def uploadSecuritySelectionModels(request):    return render(request, 'uploadModelWithSecurity.html')@require_POSTdef upload(request):    # The assumption here is that jQuery File Upload    # has been configured to send files one at a time.    # If multiple files can be uploaded simulatenously,    # 'file' may be a list of files.    filename = request.POST['filename']    csv_model_fieldnames = {'tgtWeight', 'currentWeight', 'hasChildNode', 'ext_model_id', 'ssm_id',                            'classificationName_id', 'parent_id', 'isSSMNameNode'}    if (request.POST["includeHeaders"] == "off"):        file = csv.DictReader(request.FILES['csv_file'], fieldnames=csv_model_fieldnames)        filename = request.POST['filename']        fd.close()    else:        try:            file = csv.DictReader(request.FILES['csv_file'])            filename = str(request.POST['filename']).split('.')[0]            ids = csvFileReader.insertRootModelRow(file, filename)        except ObjectDoesNotExist as e:            # return render(request, 'updateModelWithSecurity.html', {'error': e}, status=500)            e.message += 'Check to see if the Target Model matches the Model Name.'            return JsonResponse({e.message}, status=500)            # file_dict = {            #    'name': basename,            #    'size': file.size,            #    'url': settings.MEDIA_URL + basename,            #    'thumbnailUrl': settings.MEDIA_URL + basename,            #   'deleteUrl': reverse('file_delete', kwargs={'pk': instance.pk}),            #   'deleteType': 'POST',            # }        id = ids['id']        SSM_id = ids['SSM_id']    return JsonResponse({'status': 'Model Created.', 'id': id, 'SSM_id': SSM_id}, safe=False)@require_POSTdef upload_delete(request, pk):    success = True    try:        instance = YOURMODEL.objects.get(pk=pk)        os.unlink(instance.file.path)        instance.delete()    except YOURMODEL.DoesNotExist:        success = False    return HttpResponse(request, success)